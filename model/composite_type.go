package model

/*
This file define composite type that is a combination of different structs.
*/

// The hash of first block. Genesis block contains nothing except for a hash.
const GENESIS_HASH = "00"

// UTXOLite solves the problem that UTXO generated by golang cannot be used as map key.
type UTXOLite struct {
	// Hex string of the transaction.
	PrevTxHash string
	// The index of the output in that transaction. Together with PrevTxHash, it identifies the unique output.
	Index int64
}

// Convert from UTXO to UTXO Lite
func GetUtxoLite(utxo *UTXO) UTXOLite {
	return UTXOLite{
		PrevTxHash: utxo.PrevTxHash,
		Index:      utxo.Index,
	}
}

// Convert back to UTXO
func GetUtxo(utxoLite *UTXOLite) UTXO {
	return UTXO{
		PrevTxHash: utxoLite.PrevTxHash,
		Index:      utxoLite.Index,
	}
}

// Ledger is a map from UTXO to actual output on transaction. Each fullnode need to
// maintain a ledger.
type Ledger struct {
	L map[UTXOLite]*Output
}

// BlockWrapper stores both the block information and it's metadata on blockchain.
type BlockWrapper struct {
	// The actual block
	B *Block
	// There can be multiple children because we allow fork.
	Children []*BlockWrapper
	// Only one parent is allowed
	Parent *BlockWrapper
	// height in the blockchain.
	Height int64
	// Ledger at that node.
	L *Ledger
}

type Blockchain struct {
	// The block with the maximum height
	Tail *BlockWrapper
	// A map from hex string of the block hash to block wrapper.
	Chain map[string]*BlockWrapper
}

// Create a new blockchain
func NewBlockChain() *Blockchain {
	// Create a genesis block that has only hash "00"
	genesisBlock := Block{
		Hash: GENESIS_HASH,
	}
	genesisBlockWrapper := BlockWrapper{
		B:      &genesisBlock,
		Height: 0,
		L:      NewLedger(),
	}
	return &Blockchain{
		Tail:  &genesisBlockWrapper,
		Chain: map[string]*BlockWrapper{GENESIS_HASH: &genesisBlockWrapper},
	}
}

func NewLedger() *Ledger {
	return &Ledger{
		L: make(map[UTXOLite]*Output),
	}
}

type TransactionPool struct {
	// TransactionPool contains all pending transactions that haven't be checked in the blockchain.
	// Key is the hex of transaction's hash, value is the transaction.
	TxPool map[string]*Transaction
}

// NewTransactionPool creates a new transaction pool with no transaction at all.
func NewTransactionPool() *TransactionPool {
	return &TransactionPool{
		TxPool: make(map[string]*Transaction),
	}
}

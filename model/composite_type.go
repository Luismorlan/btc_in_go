package model

/*
This file define composite type that is a combination of different structs.
*/

// UTXOLite solves the problem that UTXO generated by golang cannot be used as map key.
type UTXOLite struct {
	// Hex string of the transaction.
	PrevTxHash string
	// The index of the output in that transaction. Together with PrevTxHash, it identifies the unique output.
	Index int64
}

// Convert from UTXO to UTXO Lite
func GetUtxoLite(utxo *UTXO) UTXOLite {
	return UTXOLite{
		PrevTxHash: utxo.PrevTxHash,
		Index:      utxo.Index,
	}
}

// Ledger is a map from UTXO to actual output on transaction. Each fullnode need to
// maintain a ledger.
type Ledger struct {
	L map[UTXOLite]*Output
}

// BlockWrapper stores both the block information and it's metadata on blockchain.
type BlockWrapper struct {
	// The actual block
	B *Block
	// There can be multiple children because we allow fork.
	Children []*BlockWrapper
	// Only one parent is allowed
	Parent *BlockWrapper
	// height in the blockchain.
	Height int64
	// Ledger at that node.
	L Ledger
}

type Blockchain struct {
	// The block with the maximum height
	Tail *BlockWrapper
	// A map from hex string of the block hash to block wrapper.
	Chain map[string]*BlockWrapper
}

// Create a new blockchain
func NewBlockChain() Blockchain {
	// Create a genesis block that has only hash "0"
	genesisBlock := &Block{
		Hash: "0",
	}
	genesisBlockWrapper := BlockWrapper{
		B:      genesisBlock,
		Height: 0,
		L:      NewLedger(),
	}
	bc := Blockchain{
		Tail:  &genesisBlockWrapper,
		Chain: map[string]*BlockWrapper{"0": &genesisBlockWrapper},
	}
	return bc
}

func NewLedger() Ledger {
	return Ledger{
		L: make(map[UTXOLite]*Output),
	}
}

type TransactionPool struct {
	// TransactionPool contains all pending transactions that haven't be checked in the blockchain.
	// Key is the hex of transaction's hash, value is the transaction.
	TxPool map[string]Transaction
}

// NewTransactionPool creates a new transaction pool with no transaction at all.
func NewTransactionPool() TransactionPool {
	return TransactionPool{
		TxPool: make(map[string]Transaction),
	}
}
